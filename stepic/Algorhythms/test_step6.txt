10
1 8
0 9
5 5
7 7
1 5
3 5
4 9
6 8
8 9
2 2

    Заметим сначала, что можно рассматривать только те решения, в которых каждая из точек находится на правом конце
какого-либо отрезка. Действительно, нетрудно понять, что любое решение, если оно не удовлетворяет этому свойству, можно
привести к нему, сдвигая его точки вправо настолько, насколько это возможно.
    Попытаемся теперь построить решение, удовлетворяющее указанному свойству. Возьмём точки-правые концы отрезков,
отсортируем их, и будем двигаться по ним слева направо. Если текущая точка является правым концом уже покрытого отрезка,
то мы пропускаем её. Пусть теперь текущая точка является правым концом текущего отрезка, который ещё не был покрыт до
этого. Тогда мы должны добавить в ответ текущую точку, и отметить все отрезки, которым принадлежит эта точка, как
покрытые. Действительно, если бы мы пропустили текущую точку и не стали бы добавлять её в ответ, то, так как она
является правым концом текущего отрезка, то мы уже не смогли бы покрыть текущий отрезок.
    Однако при наивной реализации этот метод будет работать за O (N2). Опишем эффективную реализацию этого метода.
    Возьмём все точки-концы отрезков (как левые, так и правые) и отсортируем их. При этом для каждой точки сохраним
вместе с ней номер отрезка, а также то, каким концом его она является (левым или правым). Кроме того, отсортируем
точки таким образом, что, если есть несколько точек с одной координатой, то сначала будут идти левые концы, и только
потом - правые. Заведём стек, в котором будут храниться номера отрезков, рассматриваемых в данный момент; изначально
стек пуст. Будем двигаться по точкам в отсортированном порядке. Если текущая точка - левый конец, то просто добавляем
номер её отрезка в стек. Если же она является правым концом, то проверяем, не был ли покрыт этот отрезок (для этого
можно просто завести массив булевых переменных). Если он уже был покрыт, то ничего не делаем и переходим к следующей
точке (забегая вперёд, мы утверждаем, что в этом случае в стеке текущего отрезка уже нет). Если же он ещё не был покрыт,
то мы добавляем текущую точку в ответ, и теперь мы хотим отметить для всех текущих отрезков, что они становятся
покрытыми. Поскольку в стеке как раз хранятся номера непокрытых ещё отрезков, то будем доставать из стека по одному
отрезку и отмечать, что он уже покрыт, пока стек полностью не опустеет. По окончании работы алгоритма все отрезки будут
покрыты, и притом наименьшим числом точек (повторимся, здесь важно требование, что при равенстве координат сначала идут
левые концы, и только затем правые).

    Таким образом, весь алгоритм выполняется за O (N), не считая сортировки точек, а итоговая сложность алгоритма как раз
равна O (N log N).